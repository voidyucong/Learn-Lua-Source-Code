<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>Table</title><link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css'><style type='text/css'>html, body {overflow-x: initial !important;}html { font-size: 14px; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 1rem; line-height: 1.42857143; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); overflow-x: hidden; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { background-color: rgb(181, 214, 252); text-shadow: none; background-position: initial initial; background-repeat: initial initial; }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; word-wrap: break-word; position: relative; padding-bottom: 70px; white-space: pre-wrap; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
@media screen and (max-width: 500px) { 
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
.typora-export #write { margin: 0px auto; }
#write > p:first-child, #write > ul:first-child, #write > ol:first-child, #write > pre:first-child, #write > blockquote:first-child, #write > div:first-child, #write > table:first-child { margin-top: 30px; }
img { max-width: 100%; }
input, button, select, textarea { color: inherit; font-family: inherit; font-size: inherit; font-style: inherit; font-variant-caps: inherit; font-weight: inherit; line-height: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
::before, ::after, * { box-sizing: border-box; }
#write p, #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write div, #write pre { width: inherit; }
#write p, #write h1, #write h2, #write h3, #write h4, #write h5, #write h6 { position: relative; }
h1 { font-size: 2rem; }
p { -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; -webkit-margin-start: 0px; -webkit-margin-end: 0px; }
.mathjax-block { margin-top: 0px; margin-bottom: 0px; -webkit-margin-before: 0rem; -webkit-margin-after: 0rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: bold; font-style: italic; }
a { cursor: pointer; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; margin: 4px 0px 0px; }
tr { page-break-inside: avoid; page-break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; page-break-inside: auto; text-align: left; }
table.md-table td { min-width: 80px; }
.CodeMirror-gutters { border-right-width: 0px; background-color: inherit; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
pre { white-space: pre-wrap; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences, pre.md-fences { font-size: 0.9rem; display: block; page-break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background-image: inherit; background-size: inherit; background-attachment: inherit; background-origin: inherit; background-clip: inherit; background-color: inherit; position: relative !important; background-position: inherit inherit; background-repeat: inherit inherit; }
.md-fences .CodeMirror.CodeMirror-wrap { top: -1.6em; margin-bottom: -1.6em; }
.md-fences.mock-cm { white-space: pre-wrap; }
.show-fences-line-number pre.md-fences { padding-left: 0px; }
.show-fences-line-number pre.md-fences.mock-cm { padding-left: 40px; }
.footnotes { color: rgb(136, 136, 136); font-size: 0.9rem; padding-top: 1em; padding-bottom: 1em; }
.footnotes + .footnotes { margin-top: -1em; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background-color: transparent; text-decoration: none; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 1rem; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; line-height: normal; font-weight: normal; text-align: left; box-sizing: content-box; direction: ltr; background-position: initial initial; background-repeat: initial initial; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li p, li .mathjax-block { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; }
@media print { 
  html, body { height: 100%; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  h1, h2, h3, h4, h5, h6 { page-break-after: avoid; break-after: avoid-page; orphans: 2; }
  p { orphans: 4; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 1cm; padding-right: 1cm; }
  .typora-export #write::after { height: 0px; }
  @page { margin: 20mm 0mm; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
#write pre.md-meta-block { font-size: 0.8rem; min-height: 2.86rem; white-space: pre-wrap; background-color: rgb(204, 204, 204); display: block; background-position: initial initial; background-repeat: initial initial; }
p > .md-image:only-child { display: inline-block; width: 100%; text-align: center; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.mathjax-block { white-space: pre; overflow: hidden; width: 100%; }
p + .mathjax-block { margin-top: -1.143rem; }
.mathjax-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: none; box-shadow: none; }
.task-list { list-style-type: none; }
.task-list-item { position: relative; padding-left: 1em; }
.task-list-item input { position: absolute; top: 0px; left: 0px; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-top-left-radius: 10px; border-top-right-radius: 10px; border-bottom-right-radius: 10px; border-bottom-left-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc::after, .md-toc-content::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: bold; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) { 
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { color: inherit; font-size: inherit; font-style: inherit; font-weight: inherit; text-decoration: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: '.'; }
.md-tag { opacity: 0.5; }
code { text-align: left; }
h1 .md-tag, h2 .md-tag, h3 .md-tag, h4 .md-tag, h5 .md-tag, h6 .md-tag { font-weight: initial; opacity: 0.35; }
a.md-header-anchor.md-print-anchor { border: none !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: none !important; background-color: transparent !important; text-shadow: initial !important; background-position: initial initial !important; background-repeat: initial initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.mathjax-block .MathJax_SVG_Display { text-align: center; margin: 1em 0em; position: relative; text-indent: 0px; max-width: none; max-height: none; min-width: 0px; min-height: 0px; width: 100%; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: monospace; }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: normal; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { -webkit-transition: none; transition: none; }


@include-when-export url(http://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext);

/**
 * css forked from https://github.com/GitbookIO/gitbook 
 * www.gitbook.com
 * Apache License
 * https://github.com/GitbookIO/gitbook/blob/master/LICENSE
 **/

@font-face {
    font-family: 'Open Sans';
    font-style: normal;
    font-weight: normal;
    src: local('Open Sans Regular'),url('file:///Users/yucong/Library/Application%20Support/abnerworks.Typora/themes/./github/400.woff') format('woff')
}

@font-face {
    font-family: 'Open Sans';
    font-style: italic;
    font-weight: normal;
    src: local('Open Sans Italic'),url('file:///Users/yucong/Library/Application%20Support/abnerworks.Typora/themes/./github/400i.woff') format('woff')
}

@font-face {
    font-family: 'Open Sans';
    font-style: normal;
    font-weight: bold;
    src: local('Open Sans Bold'),url('file:///Users/yucong/Library/Application%20Support/abnerworks.Typora/themes/./github/700.woff') format('woff')
}

@font-face {
    font-family: 'Open Sans';
    font-style: italic;
    font-weight: bold;
    src: local('Open Sans Bold Italic'),url('file:///Users/yucong/Library/Application%20Support/abnerworks.Typora/themes/./github/700i.woff') format('woff')
}

html {
    font-size: 16px;
}

body {
    font-family: "Open Sans","Clear Sans","Helvetica Neue",Helvetica,Arial,sans-serif;
    color: rgb(51, 51, 51);
    line-height: 1.6;
}

#write{
    max-width: 800px;
  	margin: 0 auto;
  	padding: 20px 30px 40px 30px;
	padding-top: 20px;
}

#write:after{
	height:80px;
}

#write > ul:first-child,
#write > ol:first-child{
    margin-top: 30px;
}

body > *:first-child {
    margin-top: 0 !important;
}
body > *:last-child {
    margin-bottom: 0 !important;
}
a {
    color: #4183C4;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 1rem;
    font-weight: bold;
    line-height: 1.4;
    cursor: text;
}
h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    /*background: url("file:///Users/yucong/Library/Application%20Support/abnerworks.Typora/themes/../../images/modules/styleguide/para.png") no-repeat 10px center;*/
    text-decoration: none;
}
h1 tt,
h1 code {
    font-size: inherit;
}
h2 tt,
h2 code {
    font-size: inherit;
}
h3 tt,
h3 code {
    font-size: inherit;
}
h4 tt,
h4 code {
    font-size: inherit;
}
h5 tt,
h5 code {
    font-size: inherit;
}
h6 tt,
h6 code {
    font-size: inherit;
}
h1 {
    padding-bottom: .3em;
    font-size: 2.25em;
    line-height: 1.2;
    border-bottom: 1px solid #eee;
}
h2 {
   padding-bottom: .3em;
    font-size: 1.75em;
    line-height: 1.225;
    border-bottom: 1px solid #eee;
}
h3 {
    font-size: 1.5em;
    line-height: 1.43;
}
h4 {
    font-size: 1.25em;
}
h5 {
    font-size: 1em;
}
h6 {
   font-size: 1em;
    color: #777;
}
p,
blockquote,
ul,
ol,
dl,
table{
    margin: 0.8em 0;
}
li>ol,
li>ul {
    margin: 0 0;
}
hr {
    height: 4px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
    border-bottom: 1px solid #ddd;
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0;
}
body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}
body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0;
}
body > h3:first-child,
body > h4:first-child,
body > h5:first-child,
body > h6:first-child {
    margin-top: 0;
    padding-top: 0;
}
a:first-child h1,
a:first-child h2,
a:first-child h3,
a:first-child h4,
a:first-child h5,
a:first-child h6 {
    margin-top: 0;
    padding-top: 0;
}
h1 p,
h2 p,
h3 p,
h4 p,
h5 p,
h6 p {
    margin-top: 0;
}
li p.first {
    display: inline-block;
}
ul,
ol {
    padding-left: 30px;
}
ul:first-child,
ol:first-child {
    margin-top: 0;
}
ul:last-child,
ol:last-child {
    margin-bottom: 0;
}
blockquote {
    border-left: 4px solid #dddddd;
    padding: 0 15px;
    color: #777777;
}
blockquote blockquote {
    padding-right: 0;
}
table {
    padding: 0;
}
table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0;
}
table tr:nth-child(2n) {
    background-color: #f8f8f8;
}
table tr th {
    font-weight: bold;
    border: 1px solid #cccccc;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}
table tr td {
    border: 1px solid #cccccc;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}
table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}
table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

.CodeMirror-gutters {
    border-right: 1px solid #ddd;
}

pre.md-fences,
.md-fences,
code,
tt {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
    border-radius: 3px;
    padding: 0;
    font-family: Consolas, "Liberation Mono", Courier, monospace;
    padding: 2px 4px 0px 4px;
    font-size: 0.9em;
}
pre.md-fences,
.md-fences {
    margin-bottom: 15px;
    margin-top: 15px;
    padding: 0.2em 1em;
    padding-top: 8px;
    padding-bottom: 6px;
}
.task-list{
	padding-left: 0;
}

.task-list-item {
	padding-left:32px;
}

.task-list-item input {
  top: 3px;
  left: 8px;
}

@media screen and (min-width: 914px) {
    /*body {
        width: 854px;
        margin: 0 auto;
    }*/
}
@media print {
    html {
        font-size: 13px;
    }
    table,
    pre {
        page-break-inside: avoid;
    }
    pre {
        word-wrap: break-word;
    }
}

.md-fences {
	background-color: #f8f8f8;
}
#write pre.md-meta-block {
	padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block>.code-tooltip {
	bottom: .375rem;
}

#write>h3.md-focus:before{
	left: -1.5625rem;
	top: .375rem;
}
#write>h4.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h5.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h6.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
.md-image>.md-meta {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
    border-radius: 3px;
    font-family: Consolas, "Liberation Mono", Courier, monospace;
    padding: 2px 4px 0px 4px;
    font-size: 0.9em;
    color: inherit;
}

.md-tag{
	color: inherit;
}

.md-toc { 
    margin-top:20px;
    padding-bottom:20px;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

/** focus mode */
.on-focus-mode blockquote {
    border-left-color: rgba(85, 85, 85, 0.12);
}
</style>
</head>
<body class='typora-export ' >
<div  id='write'  class = 'is-mac'><h1><a name='header-c1' class='md-header-anchor '></a>Table</h1><h2><a name='header-c6' class='md-header-anchor '></a>Table常用操作</h2><blockquote><p>插入</p></blockquote><pre class='md-fences mock-cm' style='display:block;position:relative'>local t = {}
t.x = 1</pre><blockquote><p>查找</p></blockquote><pre class='md-fences mock-cm' style='display:block;position:relative'>local t = {}
print(t.x)</pre><blockquote><p>获取长度</p></blockquote><pre class='md-fences mock-cm' style='display:block;position:relative'>local t = {1, 2, 3}
print(#t)</pre><blockquote><p>迭代</p></blockquote><pre class='md-fences mock-cm' style='display:block;position:relative'>local t = {1, 2, 3}
for k, v in pairs(t) do
	print(k, v)
end</pre><h2><a name='header-c23' class='md-header-anchor '></a>Table的基本结构</h2><p>在 Lua 实现中，Table 实际上由两部分构成：</p><ul><li>Array</li><li>Hash Table</li></ul><p>首先看一下源码中的结构（<code>lobject.h</code>）：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>typedef union TKey {
  struct {
    TValuefields;
    int next;  /* for chaining (offset for next node) */
  } nk; /* next key */
  TValue tvk; /* key */
} TKey;

/*
** hash table里的节点
 */
typedef struct Node {
  TValue i_val;
  TKey i_key;
} Node;


typedef struct Table {
  CommonHeader;
  lu_byte flags;  /* 1&lt;&lt;p means tagmethod(p) is not present */
  lu_byte lsizenode;
  unsigned int sizearray;
  TValue *array;
  Node *node;
  Node *lastfree;  /* any free position is before this position */
  struct Table *metatable;
  GCObject *gclist;
} Table;</pre><p>捡几个主要的字段说：</p><blockquote><p>nk</p></blockquote><p>Hash Table 中用到闭散列，也就是发生冲突的节点存储在表的另一个槽内，由 nk 指向下一个节点;其中的 next 是根据当前节点的偏移，可正可负;</p><blockquote><p>sizearray,lsizenode</p></blockquote><p>Array 的大小和 Hash Table 的大小，由于哈希表的大小一定为 2 的整数次幂，所以这里的 lsizenode 表示的是幂次，而不是实际大小;</p><blockquote><p>array,node</p></blockquote><p>Array 和 Hash Table;</p><blockquote><p>lastfree</p></blockquote><p>用于指向 Hash Table 中的空闲位置;</p><blockquote><p>flags</p></blockquote><p>位图，每一位代表的是一个元方法类型，可快速判断当前 table 是否有某个元方法。</p><h2><a name='header-c64' class='md-header-anchor '></a>插入</h2><p>获取 key 的 value 并设置；key 不存在则创建新 key。</p><p>插入操作主要是通过 <code>settableProtected</code>（lvm.c） 宏完成的操作。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>/* same for &#39;luaV_settable&#39; */
#define settableProtected(L,t,k,v) { const TValue *slot; \
  if (!luaV_fastset(L,t,k,slot,luaH_get,v)) \
    Protect(luaV_finishset(L,t,k,v,slot)); }</pre><p><code>luaV_fastset</code> 方法会从 table 中获取 key 是否存在，存在则这是 value 的值；否则，执行 <code>luaV_finishset</code>，如果 t 是 table 类型，则会创建一个新 key 并设置 value；如果 t 不是 table 类型，那就从 t 中获取元方法 <code>__newindex</code> 并执行对应的操作；</p><p>这种情况下，会判断给定的 key 是 string 还是 number，string后面会讲到，单说number。</p><p>首先，判断 key 在不在 array 的区间中，如果在，则直接对 array 操作；</p><p>否则，从 Hash Table 中获取 key 对应的 value 信息，如果 value ~= nil，说明 Hash Table 存在此 key，则直接对 Hash Table 操作；</p><p>key 既不在 array 中也不在 Hash Table 中，那么就需要执行 <code>luaH_newKey</code> 创建一个新 key。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>/*
** inserts a new key into a hash table; first, check whether key&#39;s main
** position is free. If not, check whether colliding node is in its main
** position or not: if it is not, move colliding node to an empty place and
** put new key in its main position; otherwise (colliding node is in its main
** position), new key goes to an empty position.
*/
TValue *luaH_newkey (lua_State *L, Table *t, const TValue *key) {
  Node *mp;
  TValue aux;
  if (ttisnil(key)) luaG_runerror(L, &quot;table index is nil&quot;);
  else if (ttisfloat(key)) {
    lua_Integer k;
    if (luaV_tointeger(key, &amp;k, 0)) {  /* index is int? */
      setivalue(&amp;aux, k);
      key = &aux;  /* insert it as an integer */
    }
    else if (luai_numisnan(fltvalue(key)))
      luaG_runerror(L, &quot;table index is NaN&quot;);
  }
  mp = mainposition(t, key); // 获取key的mainposition
  if (!ttisnil(gval(mp)) || isdummy(mp)) {  /* main position is taken? */
    Node *othern;
    Node *f = getfreepos(t);  /* get a free place */
    if (f == NULL) {  /* cannot find a free place? */
      rehash(L, t, key);  /* grow table */
      /* whatever called &#39;newkey&#39; takes care of TM cache */
      return luaH_set(L, t, key);  /* insert key into grown table */
    }
    lua_assert(!isdummy(f));
    othern = mainposition(t, gkey(mp));
    if (othern != mp) {  /* is colliding node out of its main position? */
      /* yes; move colliding node into free position */
      while (othern + gnext(othern) != mp)  /* find previous */
        othern += gnext(othern);
      gnext(othern) = cast_int(f - othern);  /* rechain to point to &#39;f&#39; */
      *f = *mp;  /* copy colliding node into free pos. (mp-&gt;next also goes) */
      if (gnext(mp) != 0) { //
        gnext(f) += cast_int(mp - f);  /* correct &#39;next&#39; */
        gnext(mp) = 0;  /* now &#39;mp&#39; is free */
      }
      setnilvalue(gval(mp));
    }
    else {  /* colliding node is in its own main position */
      /* new node will go into free position */
      if (gnext(mp) != 0)
        gnext(f) = cast_int((mp + gnext(mp)) - f);  /* chain new position */
      else lua_assert(gnext(f) == 0);
      gnext(mp) = cast_int(f - mp);
      mp = f;
    }
  }
  setnodekey(L, &amp;mp-&gt;i_key, key);
  luaC_barrierback(L, t, key);
  lua_assert(ttisnil(gval(mp)));
  return gval(mp);
}</pre><p><code>luaH_newkey</code>是对 Hash Table 添加 一个新 key 的操作并返回对应的 value。Table 使用闭散列表，发生冲突时会写入空闲的位置并链到冲突链表的最后面。</p><p><strong>向 Hash Table 中插入及冲突处理过程如下：</strong></p><p><img src='https://raw.githubusercontent.com/voidyucong/Learn-Lua-Source-Code/master/pic/Lua%20Table%20New%20Key.png' alt='Lua Table New Key' /></p><p>当 Hash Table 没有空余位置时会出发 rehash 操作。rehash 的主要工作是统计当前 table 中到底有多少有效键值对，以及决定数组部分需要开辟多少空间。 其原则是最终数组部分的利用率需要超过 50%。如果 array 中的有效元素过少或者但是需要的空间较大（例如在下标 1、2、100 处存在三个元素，则没必要开辟 100 的空间存放），则会相应调整 array 的尺寸，并把多余的元素放到 Hash Table 中，已达到较高的空间利用率。</p><p>例如：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>local t = {1, 2, nil, nil, 5} -- 1
t.x = 1  -- 2</pre><p>在table t 创建时，会把所有元素放置到 array 中，并设置 sizearray = 5，lsizenode = 0；</p><p>接下来对 t 创建了一个新的key x，所以会对 Hash Table 进行 rehash 以容纳所有的 key-value 类型；</p><p>rehash 过程中也会对 array 进行 resize，根据现有的大小会调整为8，之后发现有效元素只有3个（1、2、5），没超过 50% 使用率，所以会设置 sizearray = 4 并且将超出的元素 5 放到 Hash Table中；同理，收缩后发现有效元素（1、2）还是没超过 50% 利用率，设置 sizearray = 2；</p><p>最终，sizearray = 2，array 中存放1、2，lsizenode = 1，Hash Table 中存放 5、x；</p><h2><a name='header-c101' class='md-header-anchor '></a>获取长度</h2><h3><a name='header-c102' class='md-header-anchor '></a>思考</h3><pre class='md-fences mock-cm' style='display:block;position:relative'>t = {1, nil, nil, 4, 5}
print(#t)

t = {1, 2, 3, nil, nil}
print(#t)

t = {1, 2, nil, 4, nil}
print(#t)

t = {1, nil, 2, 3, 4}
t[100]=100
t.x=1
print(#t)</pre><p>获取长度是通过 luaH_getn 方法实现的（ltable.c）：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>/*
** Try to find a boundary in table &#39;t&#39;. A &#39;boundary&#39; is an integer index
** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).
*/
int luaH_getn (Table *t) {
  unsigned int j = t-&gt;sizearray;
  if (j &gt; 0 &amp;&amp; ttisnil(&amp;t-&gt;array[j - 1])) {
    /* there is a boundary in the array part: (binary) search for it */
    unsigned int i = 0;
    while (j - i &gt; 1) {
      unsigned int m = (i+j)/2;
      if (ttisnil(&amp;t-&gt;array[m - 1])) j = m;
      else i = m;
    }
    return i;
  }
  /* else must find a boundary in hash part */
  else if (isdummy(t-&gt;node))  /* hash part is empty? */
    return j;  /* that is easy... */
  else return unbound_search(t, j);
}</pre><p>此方法有三个分支判断：</p><ul><li><strong>1</strong> . 如果 sizearray 大于0，并且 array 的最后一个元素是 nil，则从[0 - sizearray]<strong>二分查找 值不是 nil 但是后一个值是 nil 的位置</strong>，直接返回。
例如对 <code>t = {1, 2, nil, 4, nil}</code> 取长度，过程如下：</li></ul><blockquote><ul><li>左边界 <code>i = 0</code>，右边界 <code>j = 5</code>，<code>array[(i + j) / 2] != nil</code>，所以令 <code>i = (i + j) / 2</code>;</li></ul></blockquote><blockquote><ul><li>左边界 <code>i = 2</code>，右边界 <code>j = 5</code>，<code>array[(i + j) / 2] == nil</code>，所以令 <code>j = (i + j) / 2</code>;</li></ul></blockquote><blockquote><ul><li>左边界 <code>i = 2</code>，右边界 <code>j = 3</code>，i 和 j 已相邻，返回 i 的值2;</li></ul></blockquote><ul><li><strong>2</strong> . 如果 sizearry 小于0 或者 最后一个元素不是nil，则判断 Hash Table 是否是假的数据，如果是，则直接返回 sizearray。</li><li><strong>3</strong> . 前两个条件都不满足，则执行 <code>unbound_search</code>。在 <code>unbound_search</code> ，会从 Hash Table 中从 sizearray + 1 开始查找空元素，每次步进为2次幂；找到后进行第一步二分查找边界值，并返回。</li><li>例如对 <code>t = {1, nil, 3, 4, 5}; t.x = 1;</code> 取长度，过程如下：</li></ul><blockquote><ul><li>暂定左边界 <code>i = sizearray = 4</code>，<code>j = sizearray + 1 = 5</code>，<code>node[j] ~= nil</code>，所以令 <code>j *= 2</code>;</li></ul></blockquote><blockquote><ul><li><code>node[10] == nil</code>，所以确定右边界 <code>j = 10</code>;</li></ul></blockquote><blockquote><ul><li>二分查找，最后确定 <code>i = 5</code>并返回;</li></ul></blockquote><p>下面给出上方的答案：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>&gt; t = {1, nil, nil, 4, 5}
&gt; print(#t)
5

&gt; t = {1, 2, 3, nil, nil}
&gt; print(#t)
3

&gt; t = {1, 2, nil, 4, nil}
&gt; print(#t)
2

&gt; t = {1, nil, 2, 3, 4}
&gt; t[100]=100
&gt; t.x=1
&gt; print(#t)
5</pre><p>结论：在不确定的情况下最好用 <code>table.count</code> 或者自定义 <code>__len</code> 方法。</p><h2><a name='header-c163' class='md-header-anchor '></a>迭代</h2><h3><a name='header-c164' class='md-header-anchor '></a>pairs</h3><p>Lua 提供了一个 next 方法，传入上一个键，返回下一个键值对，而 pairs 也是用的这个方法，也就是luaH_next（ltable.c）。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>int luaH_next (lua_State *L, Table *t, StkId key) {
  unsigned int i = findindex(L, t, key);  /* find original element */
  for (; i &lt; t-&gt;sizearray; i++) {  /* try first array part */
    if (!ttisnil(&amp;t-&gt;array[i])) {  /* a non-nil value? */
      setivalue(key, i + 1);
      setobj2s(L, key+1, &amp;t-&gt;array[i]);
      return 1;
    }
  }
  for (i -= t-&gt;sizearray; cast_int(i) &lt; sizenode(t); i++) {  /* hash part */
    if (!ttisnil(gval(gnode(t, i)))) {  /* a non-nil value? */
      setobj2s(L, key, gkey(gnode(t, i)));
      setobj2s(L, key+1, gval(gnode(t, i)));
      return 1;
    }
  }
  return 0;  /* no more elements */
}</pre><p>它尝试在 array 中获取下一个值，当超出 array 部分后，则检索 Hash Table 中的位置。</p><p>而对键的预先操作是在 findinex 中完成的，如果给定的键是nil，返回0，否则，会在 array 和 Hash Table 中查找并返回相应的值。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>/*
** returns the index of a &#39;key&#39; for table traversals. First goes all
** elements in the array part, then elements in the hash part. The
** beginning of a traversal is signaled by 0.
*/
static unsigned int findindex (lua_State *L, Table *t, StkId key) {
  unsigned int i;
  if (ttisnil(key)) return 0;  /* first iteration */
  i = arrayindex(key);
  if (i != 0 &amp;&amp; i &lt;= t-&gt;sizearray)  /* is &#39;key&#39; inside array part? */
    return i;  /* yes; that&#39;s the index */
  else {
    int nx;
    Node *n = mainposition(t, key);
    for (;;) {  /* check whether &#39;key&#39; is somewhere in the chain */
      /* key may be dead already, but it is ok to use it in &#39;next&#39; */
      if (luaV_rawequalobj(gkey(n), key) ||
            (ttisdeadkey(gkey(n)) &amp;&amp; iscollectable(key) &amp;&amp;
             deadvalue(gkey(n)) == gcvalue(key))) {
        i = cast_int(n - gnode(t, 0));  /* key index in hash table */
        /* hash elements are numbered after array ones */
        return (i + 1) + t-&gt;sizearray;
      }
      nx = gnext(n);
      if (nx == 0)
        luaG_runerror(L, &quot;invalid key to &#39;next&#39;&quot;);  /* key not found */
      else n += nx;
    }
  }
}</pre><h3><a name='header-c173' class='md-header-anchor '></a>ipairs</h3><p>ipairs 是通过 lua_geti 方法根据给定的 int 类型键查找，当遇到 nil 后停止，控制循环的代码在 lvm.c 中，后面的章节会讲到。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>LUA_API int lua_geti (lua_State *L, int idx, lua_Integer n) {
  StkId t;
  const TValue *slot;
  lua_lock(L);
  t = index2addr(L, idx);
  if (luaV_fastget(L, t, n, slot, luaH_getint)) {
    setobj2s(L, L-&gt;top, slot);
    api_incr_top(L);
  }
  else {
    setivalue(L-&gt;top, n);
    api_incr_top(L);
    luaV_finishget(L, t, L-&gt;top - 1, L-&gt;top - 1, slot);
  }
  lua_unlock(L);
  return ttnov(L-&gt;top - 1);
}</pre><h2><a name='header-c177' class='md-header-anchor '></a>元表</h2><p>由于很多操作都需要对元表的元方法进行访问，并非所有元表都提供了需要的元方法，所以查询一个元方法存不存在就需要特别的优化。</p><p>每个 Table 结构中都有一个 flags 字段，它用位的方式记录当前有哪些元方法。</p><p>下面是从 table 中获取指定 key 的值。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>void luaV_finishget (lua_State *L, const TValue *t, TValue *key, StkId val,
                      const TValue *slot) {
  int loop;  /* counter to avoid infinite loops */
  const TValue *tm;  /* metamethod */
  for (loop = 0; loop &lt; MAXTAGLOOP; loop++) { /* 处理MAXTAGLOOP(2000)层的元表 */
    if (slot == NULL) {  /* &#39;t&#39; is not a table? */
      lua_assert(!ttistable(t));
      tm = luaT_gettmbyobj(L, t, TM_INDEX);
      if (ttisnil(tm))
        luaG_typeerror(L, t, &quot;index&quot;);  /* no metamethod */
      /* else will try the metamethod */
    }
    else {  /* &#39;t&#39; is a table */
      lua_assert(ttisnil(slot));
      tm = fasttm(L, hvalue(t)-&gt;metatable, TM_INDEX);  /* table&#39;s metamethod */
      if (tm == NULL) {  /* no metamethod? */
        setnilvalue(val);  /* result is nil */
        return;
      }
      /* else will try the metamethod */
    }
    if (ttisfunction(tm)) {  /* is metamethod a function? */
      luaT_callTM(L, tm, t, key, val, 1);  /* call it */
      return;
    }
    t = tm;  /* else try to access &#39;tm[key]&#39; */
    if (luaV_fastget(L,t,key,slot,luaH_get)) {  /* fast track? */
      setobj2s(L, val, slot);  /* done */
      return;
    }
    /* else repeat (tail call &#39;luaV_finishget&#39;) */
  }
  luaG_runerror(L, &quot;&#39;__index&#39; chain too long; possible loop&quot;);
}</pre><p>luaV_finishget 一般是在 table 中直接获取 key 不存在时的后续步骤。如果 table 中没有，则从 metatable 中查找<strong>index元方法，如果</strong>index存在并且是 function，则调用 luaT_callTM 执行 __index 方法。否则将 metatable 按照同样的方法执行。注意，层次深度定义为宏 <strong>MAXTAGLOOP(1000)</strong>。</p><pre class='md-fences mock-cm' style='display:block;position:relative'>void luaT_callTM (lua_State *L, const TValue *f, const TValue *p1,
                  const TValue *p2, TValue *p3, int hasres) {
  ptrdiff_t result = savestack(L, p3);
  StkId func = L-&gt;top;
  setobj2s(L, func, f);  /* push function (assume EXTRA_STACK) */
  setobj2s(L, func + 1, p1);  /* 1st argument */
  setobj2s(L, func + 2, p2);  /* 2nd argument */
  L-&gt;top += 3;
  if (!hasres)  /* no result? &#39;p3&#39; is third argument */
    setobj2s(L, L-&gt;top++, p3);  /* 3rd argument */
  /* metamethod may yield only when called from Lua code */
  if (isLua(L-&gt;ci))
    luaD_call(L, func, hasres);
  else
    luaD_callnoyield(L, func, hasres);
  if (hasres) {  /* if has result, move it to its place */
    p3 = restorestack(L, result);
    setobjs2s(L, p3, --L-&gt;top);
  }
}</pre><p>所有元方法的参数都是 table、key，并把结果返回。</p></div>
</body>
</html>